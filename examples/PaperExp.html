<!DOCTYPE html>
<html>
<head>
    <title>Exp 4 paper</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="Generator" content="https://github.com/callumprentice/ThreeJsAppTemplate">
    <style type="text/css">
        body {
            background-color: #000;
            color: #ff0;
            margin: 0;
            overflow: hidden;
        }
        #title {
            width:440px ;
            background-color:rgba(100,100,100,0.6);
            top:16px;
            left: 16px;
            height: 58px;
            position:absolute;
            padding: 12px;
            padding-top:4px;
            z-index:10;
            color:yellow;
            font-family: Verdana, Arial;
            font-size: 0.75em;
            border-radius: 10px
        }
        a {
            color: orange;
            text-decoration: none;
        }
    </style>


</head>
<body>
<script type="text/javascript" src="../build/three.js"></script>
<script type="text/javascript" src="js/controls/TrackballControls.js"></script>
<script type="text/javascript" src="js/Detector.js"></script>
<script type="text/javascript" src="js/libs/dat.gui.min.js"></script>

<script type = "text/javascript">
    var camera, scene, renderer, controls;
    var terrain;
    var terrain_info, water_mesh, water_height = 0.25;
    var terrain_detail = 6, terrain_roughness = 0.7;
    var cylinder_slices = 10;
    var cylinder_mesh;
    function Terrain(detail) {
        this.size = Math.pow(2, detail) + 1;
        this.max = this.size - 1;
        this.map = new Float32Array(this.size * this.size);
    }
    Terrain.prototype.get = function (x, y) {
        if (x < 0 || x > this.max || y < 0 || y > this.max) return -1;
        return this.map[x + this.size * y];
    };
    Terrain.prototype.set = function (x, y, val) {
        this.map[x + this.size * y] = val;
    };
    Terrain.prototype.generate = function (roughness) { // 生成一块疤痕区域
        var self = this;
        this.set(0, 0, self.max);
        this.set(this.max, 0, self.max / 2);
        this.set(this.max, this.max, 0);
        this.set(0, this.max, self.max / 2);
        divide(this.max);
        function divide(size) {
            var x, y, half = size / 2;
            var scale = roughness * size;
            if (half < 1) return;
            for (y = half; y < self.max; y += size) {
                for (x = half; x < self.max; x += size) {
                    square(x, y, half, Math.random() * scale * 2 - scale);
                }
            }
            for (y = 0; y <= self.max; y += half) {
                for (x = (y + half) % size; x <= self.max; x += size) {
                    diamond(x, y, half, Math.random() * scale * 2 - scale);
                }
            }
            divide(size / 2);
        }
        function average(values) {
            var valid = values.filter(function (val) {
                return val !== -1;
            });
            var total = valid.reduce(function (sum, val) {
                return sum + val;
            }, 0);
            return total / valid.length;
        }
        function square(x, y, size, offset) {
            var ave = average([
                self.get(x - size, y - size), // upper left
                self.get(x + size, y - size), // upper right
                self.get(x + size, y + size), // lower right
                self.get(x - size, y + size) // lower left
            ]);
            self.set(x, y, ave + offset);
        }
        function diamond(x, y, size, offset) {
            var ave = average([
                self.get(x, y - size), // top
                self.get(x + size, y), // right
                self.get(x, y + size), // bottom
                self.get(x - size, y) // left
            ]);
            self.set(x, y, ave + offset);
        }
    };
    function Bearing(slices){

    };
    Bearing.prototype.addMesh = function (scar) { //将信息制成geometry，显示出来
        var self = this;
        //var terrain_geometry = new THREE.PlaneGeometry(512, 512, this.size - 1, this.size - 1);//(长度，宽度，长段数，宽段数)
        var cylinder_geometry = new THREE.CylinderGeometry(128, 128, cylinder_slices, cylinder_slices);
        var min_height = Infinity;
        var max_height = -Infinity;
        for (var y = 0; y < this.size; y++) {
            for (var x = 0; x < this.size; x++) {
                var height_val = this.get(x, y);
                if ( height_val < min_height ) min_height = height_val;
                if ( height_val > max_height ) max_height = height_val;
                //if ( height_val < 0 ) height_val = 0;
                if (y === 0 || y === this.size - 1 || x === 0 || x === this.size - 1) height_val = 0.0;
                cylinder_geometry.vertices[y * this.size + x].z = height_val;
            }
        }
        cylinder_geometry.computeFaceNormals();
        cylinder_geometry.computeVertexNormals();
        scene.remove(cylinder_mesh);
        terrain_material  = new THREE.MeshNormalMaterial();
        cylinder_mesh = new THREE.Mesh(cylinder_geometry, terrain_material);
        cylinder_mesh.rotation.x = -Math.PI / 2.0;
        scene.add(cylinder_mesh);

    };

    function init() {
        if (!Detector.webgl)
            Detector.addGetWebGLMessage();
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setClearColor(0x333366, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 100;
        camera.position.z = 600;
        var ambient_light = new THREE.AmbientLight(0xcccccc);
        scene.add(ambient_light);
        var gui = new dat.GUI();
        gui.add(this, 'cylinder_slices', 10, 32).name("slices").listen().onFinishChange(function(value) {
            generate();
        });
//        gui.add(this, 'cylinder_height_slices', 6, 12).name("height").onFinishChange(function(value) {
//            generate();
//        });
        gui.add(this, "generate").name("Generate");
//        gui.add(this, 'water_height', 0, 1.0).name("Water Height").onChange(function(value) {
//            water_mesh.scale.z = water_height;
//        });
        ;
        window.addEventListener('resize', onWindowResize, false);
        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 0.4;
        controls.noZoom = false;
        controls.noPan = true;
        controls.staticMoving = false;
        controls.dynamicDampingFactor = 0.4;
        controls.minDistance = 300;
        controls.maxDistance = 600;

        terrain = new Terrain(parseInt(terrain_detail));
        terrain.generate(terrain_roughness);
    }
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        terrain_detail = parseInt(terrain_detail);
        renderer.render(scene, camera);
    }
    function generate() {
        var bearing = new Bearing(cylinder_slices);
        bearing.addMesh(terrain);
    };
    function generateCylinder(){

    };
    init();
    generate();
    animate();
</script>

</body>
</html>